{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\nclass Bot:\n    def __init__ (self):\n        self.visited = set() # Set which stores the visited co-ords\n        self.walls = set() # Walls stored as co-ord pairs to note which paths aren't possible e.g. ((2, 3), (1, 3)) means a wall between those co-ords so the bot is not allowed to move between them\n        self.directions = [(0,1), (1,0), (0,-1), (-1,0)] # Possible directions for the bot: Up, Right, Down, Left\n        self.currentDirection = 0 # Current direction of the bot: 0 = Up, 1 = Right, 2 = Down, 3 = Left\n        self.position = (0, 0) # Bot starts at (0, 0)\n        self.exitPos = None # Bot does not know where exit is to begin with\n    \n    def turnLeft(self):\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        \n        nextPos = ( # Calculates next co-ord based on direction for wall mapping\n            self.position[0] + self.directions[(self.currentDirection - 1) % 4][0], # Current x co-ord + x co-ord 1 square ahead\n            self.position[1] + self.directions[(self.currentDirection - 1) % 4][1] # Current y co-rd + y co-ord 1 square ahead\n        )\n\n        if front_eye.near_object(): # If a wall is detected, add the current co-ords and the co-ords 1 step in-front to the set\n            self.walls.add((self.position, nextPos))\n\n        self.currentDirection = (self.currentDirection - 1) % 4 # Update current direction, calc uses % 4 to keep value 0-3\n\n    def turnRight(self):\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n        nextPos = ( # Same as left turn but 1 is added instead of subtracted to current direction to indicate right turn\n            self.position[0] + self.directions[(self.currentDirection + 1) % 4][0],\n            self.position[1] + self.directions[(self.currentDirection + 1) % 4][1]\n        )\n        \n        if front_eye.near_object():\n            self.walls.add((self.position, nextPos))\n        \n        self.currentDirection = (self.currentDirection + 1) % 4\n\n    def moveForward(self):\n        nextPos = ( # Same as both turn functions but doesn't need to account for left/right turns by +/- 1\n            self.position[0] + self.directions[self.currentDirection][0],\n            self.position[1] + self.directions[self.currentDirection][1]\n        )\n\n        if not front_eye.near_object(): # If there isn't a wall ahead, move forward otherwise add the wall co-ords to the set\n            drivetrain.drive_for(FORWARD, 250, MM)\n            self.visited.add(self.position) # Add the current co-ords to the visited set\n            self.position = nextPos # Update current position with the co-ords just moved to\n        else:\n            self.walls.add((self.position, nextPos))\n\n    # Getters and setters for required private variables\n    def getDirections(self):\n        return self.directions\n\n    def getVisited(self):\n        return self.visited\n\n    def getWalls(self):\n        return self.walls\n\n    def getCurrentPos(self):\n        return self.position\n\n    def setExitPos(self):\n        self.exitPos = self.position\n        brain.print(self.exitPos)\n\n    def getExitPos(self):\n        return self.exitPos\n\n    def getNumVisited(self):\n        return len(self.visited)\n\ndef mapMaze(bot):\n    while True: # Continues mapping maze until exit condition is met\n        bot.turnLeft() # Follow left-side of the maze\n        if front_eye.near_object(): # If a wall is detected, turn right\n            bot.turnRight()\n        if front_eye.near_object(): # If another wall is detected, turn right again\n            bot.turnRight()\n        elif front_distance.get_distance(MM) < 3000: # If distance is less than 3000mm, move forward (prevents bot from jumping off the edge at start or finish)\n            bot.moveForward()\n        else: # If bot is looking off the edge of the maze, do a 180 to prevent getting stuck\n            bot.turnLeft()\n            bot.turnLeft()\n        \n        if down_eye.detect(RED): # If exit is found, mark exit position and continue mapping\n            bot.setExitPos()\n\n        if bot.getNumVisited() >= 58 and bot.getExitPos(): # When ~90% of the maze has been mapped and the exit has been found, stop mapping\n            break\n        wait(5, MSEC) # Waits are required within loops to prevent program going unresponsive\n\ndef calcShortestPath(bot): # Calculate shortest path to exit from current position using breadth-first search\n    queue = [(bot.getCurrentPos(), [])] # Initialise queue for BFS with current co-ords and an empty path\n    visitedBFS = set() # Tracks visited co-ords during BFS\n\n    # Retrieve visited positions, possible movement directions, exit position, and walls from the bot\n    botVisited = bot.getVisited()\n    directions = bot.getDirections()\n    exitPos = bot.getExitPos()\n    walls = bot.getWalls()\n\n    while queue:\n        current, path = queue.pop(0) # Dequeue first position and it's associated path\n        if current == exitPos: # Once exit is reached, return the shortest path\n            return path\n        \n        for changeX, changeY in directions: # Try moving in all directions\n            nextPos = (current[0] + changeX, current[1] + changeY)\n\n            if ((current, nextPos) not in walls and (nextPos, current) not in walls): # Check next co-ords aren't blocked by a wall, checks (current -> next position) and (next position -> current) co-ords\n                if nextPos not in visitedBFS and nextPos in botVisited: # If next co-ords haven't been visited during BFS and were visited during mapping:\n                    visitedBFS.add(nextPos) # Mark the position as visited during BFS and\n                    queue.append((nextPos, path + [nextPos])) # Enqueue the new position and the updated path\n\n            wait(5, MSEC)\n\n        wait(5, MSEC)\n    \n    return None # If no path to the exit is found\n\n# Add project code in \"main\"\ndef main():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n\n    bot = Bot() # Initialise bot\n\n    mapMaze(bot)\n    \n    shortestPath = calcShortestPath(bot)\n\n    if shortestPath:\n        brain.new_line()\n        brain.print(\"Shortest Path: \")\n        brain.print(shortestPath)\n    else:\n        brain.new_line()\n        brain.print(\"Unable to find a path to the exit from current location.\")\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}