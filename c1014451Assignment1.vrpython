{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion\n\nclass Bot:\n    def __init__ (self):\n        self.visited = set() # Set which stores the visited co-ords\n        self.walls = set() # Walls stored as co-ord pairs to note which paths aren't possible e.g. ((2, 3), (1, 3)) means a wall between those co-ords so the bot is not allowed to move between them\n        self.directions = [(0,1), (1,0), (0,-1), (-1,0)] # Possible directions for the bot: Up, Right, Down, Left\n        self.currentDirection = 0 # Current direction of the bot: 0 = Up, 1 = Right, 2 = Down, 3 = Left\n        self.position = (0, 0) # Bot starts at (0, 0)\n        self.startPos = self.position # Save start position (home)\n        self.exitPos = None # Bot does not know where exit is to begin with\n    \n    def turnLeft(self):\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        \n        nextPos = ( # Calculates next co-ord based on direction for wall mapping\n            self.position[0] + self.directions[(self.currentDirection - 1) % 4][0], # Current x co-ord + x co-ord 1 square ahead\n            self.position[1] + self.directions[(self.currentDirection - 1) % 4][1] # Current y co-rd + y co-ord 1 square ahead\n        )\n\n        if front_eye.near_object(): # If a wall is detected, add the current co-ords and the co-ords 1 step in-front to the set\n            self.walls.add((self.position, nextPos))\n\n        self.currentDirection = (self.currentDirection - 1) % 4 # Update current direction, calc uses % 4 to keep value 0-3\n\n    def turnRight(self):\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n        nextPos = ( # Same as left turn but 1 is added instead of subtracted to current direction to indicate right turn\n            self.position[0] + self.directions[(self.currentDirection + 1) % 4][0],\n            self.position[1] + self.directions[(self.currentDirection + 1) % 4][1]\n        )\n        \n        if front_eye.near_object():\n            self.walls.add((self.position, nextPos))\n        \n        self.currentDirection = (self.currentDirection + 1) % 4\n\n    def turnBearing(self, direction): # Turn to a heading instead of by 90 degrees, takes direction between 0-3 and multiplies by 90 to get bearing\n        drivetrain.turn_to_heading((direction * 90), DEGREES)\n\n    def moveForward(self):\n        nextPos = ( # Same as both turn functions but doesn't need to account for left/right turns by +/- 1\n            self.position[0] + self.directions[self.currentDirection][0],\n            self.position[1] + self.directions[self.currentDirection][1]\n        )\n\n        if not front_eye.near_object(): # If there isn't a wall ahead, move forward otherwise add the wall co-ords to the set\n            drivetrain.drive_for(FORWARD, 250, MM)\n            self.visited.add(self.position) # Add the current co-ords to the visited set\n            self.position = nextPos # Update current position with the co-ords just moved to\n        else:\n            self.walls.add((self.position, nextPos))\n\n    # Getters and setters for required variables\n    def getDirections(self):\n        return self.directions\n\n    def getVisited(self):\n        return self.visited\n\n    def getWalls(self):\n        return self.walls\n\n    def getCurrentPos(self):\n        return self.position\n\n    def getStartPos(self):\n        return self.startPos\n\n    def getExitPos(self):\n        return self.exitPos\n\n    def getNumVisited(self):\n        return len(self.visited)\n\n    def setExitPos(self):\n        self.exitPos = self.position\n\n    def setCurrentPosAsExit(self):\n        self.position = self.exitPos\n\ndef mapMaze(bot):\n    while True: # Continues mapping maze until exit condition is met\n        if bot.getCurrentPos() in bot.getVisited(): # If the bot is backtracking, simplify wall mapping and increase mapping speed\n            bot.turnLeft() # Follow left side of maze\n        else: # If bot is mapping an unexplored area, map walls on either side of the bot\n            bot.turnLeft()\n            bot.turnRight()\n            bot.turnRight()\n            bot.turnLeft()\n            bot.turnLeft()\n        if front_eye.near_object(): # If a wall is detected, turn right\n            bot.turnRight()\n        if front_eye.near_object(): # If another wall is detected, turn right again\n            bot.turnRight()\n        # If distance is >= 3000mm and bot is at the start or at the exit, turn 180 degrees to avoid falling off the edge of the maze\n        elif front_distance.get_distance(MM) >= 3000 and (bot.getCurrentPos() is (0, 0) or down_eye.detect(RED)):\n            bot.turnLeft()\n            bot.turnLeft()\n        else: # If there are no walls or ledges, move forward 250mm to stay in grid layout\n            bot.moveForward()\n        \n        if down_eye.detect(RED): # If exit is found, mark exit position and continue mapping\n            bot.setExitPos()\n\n        if bot.getNumVisited() >= 58 and bot.getExitPos(): # When ~90% of the maze has been mapped and the exit has been found, stop mapping\n            break\n        wait(5, MSEC) # Waits are required within loops to prevent program going unresponsive\n\ndef calcShortestPath(bot, target): # Calculate shortest path to a target co-ord from current position using breadth-first search\n    currentPos = bot.getCurrentPos() # Intialise current bot position\n    queue = [(bot.getCurrentPos(), [])] # Initialise queue for BFS with current co-ords and an empty path\n    visitedBFS = set() # Tracks visited co-ords during BFS\n\n    brain.new_line()\n    brain.print(f\"Calculating path from {currentPos} to {target}.\")\n\n    # Retrieve visited positions, possible movement directions and walls from the bot\n    botVisited = bot.getVisited()\n    directions = bot.getDirections()\n    walls = bot.getWalls()\n\n    while queue:\n        current, path = queue.pop(0) # Dequeue first position and it's associated path\n        if current == target: # Once exit is reached, return the shortest path\n            return path\n        \n        for changeX, changeY in directions: # Try moving in all directions\n            nextPos = (current[0] + changeX, current[1] + changeY)\n\n            if ((current, nextPos) not in walls and (nextPos, current) not in walls): # Check next co-ords aren't blocked by a wall, checks (current -> next position) and (next position -> current) co-ords\n                if nextPos not in visitedBFS and nextPos in botVisited: # If next co-ords haven't been visited during BFS and were visited during mapping:\n                    visitedBFS.add(nextPos) # Mark the position as visited during BFS and\n                    queue.append((nextPos, path + [nextPos])) # Enqueue the new position and the updated path\n\n            wait(5, MSEC)\n\n        wait(5, MSEC)\n    \n    return None # If no path to the exit is found\n\ndef followShortestPath(bot, path):\n    currentPos = bot.getCurrentPos() # Initialise current position\n    possibleDirections = { # Dictionary of possible co-ord movements and the related direction\n            (0, 1): 0,\n            (1, 0): 1,\n            (0, -1): 2,\n            (-1, 0): 3\n        }\n\n    if path[0] != currentPos: # Add current position to the path, otherwise bot will be moving 1 step behind the path\n        path.insert(0, currentPos)\n\n    for nextPos in path: # Loop through each position in the path\n        currentX, currentY = currentPos # Split co-ord positions into x and y\n        nextX, nextY = nextPos\n\n        directionX = nextX - currentX # Calculate difference between current and next co-ords to determine direction to move\n        directionY = nextY - currentY\n        nextCoords = (directionX, directionY)\n\n        brain.new_line()\n        brain.print(f\"Current: {currentPos}, Next: {nextPos}, Delta: ({directionX}, {directionY})\")\n\n        if nextCoords in possibleDirections: # Check next co-ords are a valid direction to move in\n            nextDirection = possibleDirections[nextCoords] # Get int representation of direction from dict\n            bot.turnBearing(nextDirection) # Turn to bearing based on direction\n            bot.moveForward()\n            currentPos = nextPos # Update position to co-ord just moved to\n        else:\n            brain.new_line()\n            brain.print(f\"Invalid movement direction: {nextCoords}\")\n        \n        wait(100, MSEC)\n\ndef main():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n\n    bot = Bot() # Initialise bot\n\n    mapMaze(bot)\n    \n    shortestPath = calcShortestPath(bot, bot.getExitPos())\n\n    pen.set_pen_color(GREEN)\n\n    if shortestPath: # Check shortest path has been calculated\n        brain.new_line()\n        brain.print(f\"Shortest Path: {shortestPath}\")\n        followShortestPath(bot, shortestPath)\n        if down_eye.detect(RED): # If exit has been reached after following path, override current position to exit co-ords\n            bot.setCurrentPosAsExit()\n        else:\n            brain.new_line()\n            brain.print(\"Bot did not make it to exit.\")\n    elif bot.getCurrentPos() == bot.getExitPos(): # Check if bot is already at the exit\n        brain.new_line()\n        brain.print(\"Already at exit.\")\n    else:\n        brain.new_line()\n        brain.print(\"Unable to find a path to the exit from current location.\")\n\n    pathHome = calcShortestPath(bot, bot.getStartPos())\n\n    if pathHome: # Check path home has been calculated\n        brain.new_line()\n        brain.print(f\"Path home: {pathHome}\")\n        followShortestPath(bot, pathHome)\n    else:\n        brain.new_line()\n        brain.print(\"Unable to find a path home from the exit.\")\n\n# VR threads — Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}