{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion\n\nclass Bot: # Bot class stores mapping info and movement functions\n    def __init__ (self):\n        self.visited = set() # Set which stores the visited co-ords\n        self.walls = set() # Walls stored as co-ord pairs to note which paths aren't possible e.g. ((2, 3), (1, 3)) means a wall between those co-ords so the bot is not allowed to move between them\n        self.directions = [(0,1), (1,0), (0,-1), (-1,0)] # Possible directions for the bot: Up, Right, Down, Left\n        self.currentDirection = 0 # Current direction of the bot: 0 = Up, 1 = Right, 2 = Down, 3 = Left\n        self.position = (0, 0) # Bot starts at (0, 0)\n        self.startPos = self.position # Save start position (home)\n        self.exitPos = None # Bot does not know where exit is to begin with\n    \n    def turnLeft(self):\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        \n        nextPos = ( # Calculates next co-ord based on direction for wall mapping\n            self.position[0] + self.directions[(self.currentDirection - 1) % 4][0], # Current x co-ord + x co-ord 1 square ahead\n            self.position[1] + self.directions[(self.currentDirection - 1) % 4][1] # Current y co-rd + y co-ord 1 square ahead\n        )\n\n        if front_eye.near_object(): # If a wall is detected, add the current co-ords and the co-ords 1 step in-front to the set\n            self.walls.add((self.position, nextPos))\n\n        self.currentDirection = (self.currentDirection - 1) % 4 # Update current direction, calc uses % 4 to keep value 0-3\n\n    def turnRight(self):\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n        nextPos = ( # Same as left turn but 1 is added instead of subtracted to current direction to indicate right turn\n            self.position[0] + self.directions[(self.currentDirection + 1) % 4][0],\n            self.position[1] + self.directions[(self.currentDirection + 1) % 4][1]\n        )\n        \n        if front_eye.near_object():\n            self.walls.add((self.position, nextPos))\n        \n        self.currentDirection = (self.currentDirection + 1) % 4\n\n    def turnBearing(self, direction): # Turn to a heading instead of by 90 degrees, takes direction between 0-3 and multiplies by 90 to get bearing\n        drivetrain.turn_to_heading((direction * 90), DEGREES)\n\n    def moveForwardMapping(self):\n        nextPos = ( # Same as both turn functions but doesn't need to account for left/right turns by -/+ 1\n            self.position[0] + self.directions[self.currentDirection][0],\n            self.position[1] + self.directions[self.currentDirection][1]\n        )\n\n        if not front_eye.near_object(): # If there isn't a wall ahead, move forward otherwise add the wall co-ords to the set\n            drivetrain.drive_for(FORWARD, 250, MM)\n            self.visited.add(self.position) # Add the current co-ords to the visited set\n            self.position = nextPos # Update current position with the co-ords just moved to\n        else:\n            self.walls.add((self.position, nextPos))\n\n    def moveForwardPathing(self): # Simple drive forward when following a calculated path\n        drivetrain.drive_for(FORWARD, 250, MM)\n\n    # Getters and setters for required variables\n    def getDirections(self):\n        return self.directions\n\n    def getVisited(self):\n        return self.visited\n\n    def getWalls(self):\n        return self.walls\n\n    def getCurrentPos(self):\n        return self.position\n\n    def getStartPos(self):\n        return self.startPos\n\n    def getExitPos(self):\n        return self.exitPos\n\n    def getNumVisited(self):\n        return len(self.visited)\n\n    def setExitPos(self):\n        self.exitPos = self.position\n\n    def setCurrentPosAsExit(self):\n        self.position = self.exitPos\n\ndef mapMaze(bot):\n    while True: # Continues mapping maze until exit condition is met\n        if bot.getCurrentPos() in bot.getVisited(): # If the bot is backtracking, stop mapping walls to increase mapping speed\n            bot.turnLeft() # Follow left side of maze\n        else: # If bot is mapping an unexplored area, map walls on either side of the bot\n            bot.turnLeft()\n            bot.turnRight()\n            bot.turnRight()\n            bot.turnLeft()\n            bot.turnLeft()\n        if front_eye.near_object(): # If a wall is detected, turn right\n            bot.turnRight()\n        if front_eye.near_object(): # If another wall is detected, turn right again\n            bot.turnRight()\n        # If distance is >= 3000mm and bot is at the start or at the exit, turn 180 degrees to avoid falling off the edge of the maze\n        elif front_distance.get_distance(MM) >= 3000 and (bot.getCurrentPos() is (0, 0) or down_eye.detect(RED)):\n            bot.turnLeft()\n            bot.turnLeft()\n        else: # If there are no walls or ledges, move forward 250mm to stay in grid layout\n            bot.moveForwardMapping()\n        \n        if down_eye.detect(RED): # If exit is found, mark exit position and continue mapping\n            bot.setExitPos()\n\n        if bot.getNumVisited() >= 58 and bot.getExitPos(): # When ~90% of the maze has been mapped and the exit has been found, stop mapping\n            break\n        wait(5, MSEC) # Waits are required within while loops to prevent program going unresponsive\n\ndef calcShortestPath(bot, target): # Calculate shortest path to a target co-ord from current position using breadth-first search\n    currentPos = bot.getCurrentPos() # Intialise current bot position\n    queue = [(currentPos, [])] # Initialise queue for BFS with current co-ords and an empty path\n    visitedBFS = set() # Tracks visited co-ords during BFS\n\n    brain.new_line()\n    brain.print(f\"Calculating path from {currentPos} to {target}.\")\n\n    # Retrieve visited positions, possible movement directions and walls from the bot\n    botVisited = bot.getVisited()\n    directions = bot.getDirections()\n    walls = bot.getWalls()\n\n    while queue:\n        current, path = queue.pop(0) # Dequeue first position and it's associated path\n        if current == target: # Once exit is reached, return the shortest path\n            return path\n        \n        for changeX, changeY in directions: # Try moving in all directions\n            nextPos = (current[0] + changeX, current[1] + changeY)\n\n            if ((current, nextPos) not in walls and (nextPos, current) not in walls): # Check next co-ords aren't blocked by a wall, checks (current -> next position) and (next position -> current) co-ords\n                if nextPos not in visitedBFS and nextPos in botVisited: # If next co-ords haven't been visited during BFS and were visited during mapping:\n                    visitedBFS.add(nextPos) # Mark the position as visited during BFS and\n                    queue.append((nextPos, path + [nextPos])) # Enqueue the new position and the updated path\n\n        wait(5, MSEC)\n    \n    return None # If no path to the exit is found\n\ndef followShortestPath(bot, path):\n    currentPos = bot.getCurrentPos() # Initialise current position\n    possibleDirections = { # Dictionary of possible co-ord movements and the related direction\n            (0, 1): 0,\n            (1, 0): 1,\n            (0, -1): 2,\n            (-1, 0): 3\n        }\n\n    if path[0] != currentPos: # Add current position to the path, otherwise bot will be moving 1 step behind the path\n        path.insert(0, currentPos)\n\n    for nextPos in path: # Loop through each position in the path\n        currentX, currentY = currentPos # Split co-ord positions into x and y\n        nextX, nextY = nextPos\n\n        directionX = nextX - currentX # Calculate difference between current and next co-ords to determine direction to move\n        directionY = nextY - currentY\n        nextCoords = (directionX, directionY)\n\n        brain.new_line()\n        brain.print(f\"Current: {currentPos}, Next: {nextPos}, Delta: ({directionX}, {directionY})\")\n\n        if nextCoords in possibleDirections: # Check next co-ords are a valid direction to move in\n            nextDirection = possibleDirections[nextCoords] # Get int representation of direction from dict\n            bot.turnBearing(nextDirection) # Turn to bearing based on direction\n            bot.moveForwardPathing()\n            currentPos = nextPos # Update position to co-ord just moved to\n        else:\n            brain.new_line()\n            brain.print(f\"Invalid movement direction: {nextCoords}\")\n        \n        wait(100, MSEC)\n\ndef displayMap(bot):\n    gridSize = 17 # Maze is 8x8 but needs to be expanded to fit walls on the map\n    startPos = bot.getStartPos()\n    exitPos = bot.getExitPos()\n    visited = bot.getVisited()\n    walls = bot.getWalls()\n\n    grid = [[\"■\" for _ in range(gridSize)] for _ in range(gridSize)] # Intialise array of 17x17 to represent map\n\n    # As map is 17x17 while maze is 8x8, X and Y co-ords need to be transformed to fit onto the bigger grid\n    def transformX(x):\n        return ((x + 5) * 2) - 1\n        # x + 5 : offsets co-ord as (0, 0) is the start in the maze which is (0, 5) from bottom left\n        # * 2 : scales the co-ord up to match the increased grid size\n        # - 1 : moves co-ord left to allow for wall around the edge\n\n    def transformY(y):\n        return ((7 - y) * 2) + 1\n        # 7 - y : flips the co-ord around as y = 0 is the top in the grid but bottom in the maze\n        # * 2 : scales the co-ord up to match the increased grid size\n        # + 1 : moves co-ord down to allow for wall at the top\n\n    transformedVisited = set() # stores visited co-ords after transform\n    for x, y in visited: # loop through visited co-ords and transform to fit map grid\n        tx = transformX(x)\n        ty = transformY(y)\n        transformedVisited.add((tx, ty))\n        grid[ty][tx] = \"□\" # adds visited co-ords to grid\n\n        # Expanding from a 8x8 to 17x17 grid leaves gaps between the visited co-ords which need to be filled\n        for (x2, y2) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]: # Iterate over the adjacent co-ords of the visited set and transform them to the scaled up grid\n            tx2 = transformX(x2)\n            ty2 =transformY(y2)\n\n            if (tx2, ty2) in transformedVisited: # Check if the transformed adjacent co-ord is part of the post-transformation visited set\n                midX, midY = (tx + tx2) // 2, (ty + ty2) // 2 # Calculate the midpoint of the current transformed co-ord (tx, ty) and the adjacent transformed co-ord (tx2, ty2)\n                grid[midY][midX] = \"□\"  # Fill gaps between adjacent visited cells\n\n    for (a, b) in walls: # Add the mapped walls in\n        ax, ay = a # Split co-ord pairs into x and y\n        bx, by = b\n\n        ax = transformX(ax) # Transform co-ords to larger grid\n        ay = transformY(ay)\n        bx = transformX(bx)\n        by = transformY(by)\n\n        midX = (ax + bx) // 2 # Find midpoint of co-ords\n        midY = (ay + by) // 2\n\n        grid[midY][midX] = \"■\" # Add mapped walls to grid\n\n    sx, sy = startPos # Add start position to grid\n    sx = transformX(sx)\n    sy = transformY(sy)\n    grid[sy][sx] = \"S\"\n\n    ex, ey = exitPos # Add end position to grid\n    ex = transformX(ex)\n    ey = transformY(ey)\n    grid[ey][ex] = \"E\"\n    \n    # Print map\n    brain.new_line()\n    brain.print(\"Generated Map:\")\n    brain.new_line()\n    for row in grid:\n        brain.print(\" \".join(row))\n        brain.new_line()\n    brain.new_line()\n    brain.print(\"Legend:\")\n    brain.new_line()\n    brain.print(\"■ = wall\")\n    brain.new_line()\n    brain.print(\"□ = visited\")\n    brain.new_line()\n    brain.print(\"S = start\")\n    brain.new_line()\n    brain.print(\"E = exit\")\n\ndef main():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    pen.set_pen_color(BLUE)\n    pen.move(DOWN)\n\n    bot = Bot() # Initialise bot\n\n    mapMaze(bot)\n    \n    shortestPath = calcShortestPath(bot, bot.getExitPos())\n\n    pen.set_pen_color(GREEN) # Change pen colour to green for following path\n\n    if shortestPath: # Check shortest path has been calculated\n        brain.new_line()\n        brain.print(f\"Shortest Path: {shortestPath}\")\n        followShortestPath(bot, shortestPath)\n        if down_eye.detect(RED): # If exit has been reached after following path, override current position to exit co-ords\n            bot.setCurrentPosAsExit()\n        else:\n            brain.new_line()\n            brain.print(\"Bot did not make it to exit.\")\n    elif bot.getCurrentPos() == bot.getExitPos(): # Check if bot is already at the exit\n        brain.new_line()\n        brain.print(\"Already at exit.\")\n    else:\n        brain.new_line()\n        brain.print(\"Unable to find a path to the exit from current location.\")\n\n    pathHome = calcShortestPath(bot, bot.getStartPos())\n\n    if pathHome: # Check path home has been calculated\n        brain.new_line()\n        brain.print(f\"Path home: {pathHome}\")\n        followShortestPath(bot, pathHome)\n    else:\n        brain.new_line()\n        brain.print(\"Unable to find a path home from the exit.\")\n\n    displayMap(bot) # Display a map of the maze\n\n# VR threads — Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}